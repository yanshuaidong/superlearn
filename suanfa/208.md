280. 摆动排序
给你一个的整数数组 nums, 将该数组重新排序后使 nums[0] <= nums[1] >= nums[2] <= nums[3]... 
输入数组总是有一个有效的答案。
示例 1:
输入：nums = [3,5,2,1,6,4]
输出：[3,5,1,6,2,4]
解释：[1,6,2,5,3,4]也是有效的答案
示例 2:
输入：nums = [6,6,5,6,3,8]
输出：[6,6,5,6,3,8]

下面我直接用“面试式追问”来测你的掌握程度。你按顺序回答即可（不用写很长，但要讲清楚理由/不变量/边界）。

1）这题到底在干什么（目标是什么）
要把数组变成类似锯齿一样，上下上下的结构。



1. **核心不变量**

* 你在遍历数组做交换（或调整）时，如何用一句话描述你要维护的“不变量”？
* 当处理到下标 `i` 时，你保证了哪些位置已经满足 `<=` 或 `>=`？
当我走到i的时候，保证前面0到i已经是锯齿的形状。
具体一点如下：
从左到右扫。
每次只盯一对：i-1，i
如果这对不符合要求，就交换它两个。
做完这一对后，0到i的锯齿关系就成立了。然后继续向右。，就是i+1，和i，

2. **奇偶位策略**

* 为什么很多解法会按下标奇偶来决定比较方向（偶数位要求 `<=`，奇数位要求 `>=`）？因为要求本身就是“偶数位做小于等于、奇数位做大于等于”的交替。
更关键的是：用奇偶位，你能在 O(n) 的一次遍历里，每次只修正一对相邻元素 nums[i-1] 和 nums[i]，就把形状一步步搭出来。


* 如果我把目标改成 `nums[0] >= nums[1] <= nums[2] ...`，你的代码要改哪里？为什么？

3. **重复元素与等号**

* 有大量重复元素时（比如全是 6，或出现很多相同值），你如何解释“仍然总是有有效答案”这句话与算法的关系？
* 你的实现中，比较符号用的是 `<`/`>` 还是 `<=`/`>=`？为什么必须这样选，选错会出现什么具体反例？

4. **一次遍历 + 局部交换为何足够**

* 经典 O(n) 解法只做局部相邻交换就能保证全局满足摆动：你能给出直觉或简短证明吗？
  （提示：考虑每一步只修正当前 `i-1, i` 这一对，会不会破坏之前已经满足的关系？为什么不会/怎么避免？）

5. **反例定位**

* 如果你的代码在某些输入上失败，你最想用哪个最小反例来“打”它？
  请你给一个长度 4~6 的数组（包含重复最好），并说明失败会表现在哪个位置的关系上。

6. **复杂度与稳定性**

* 你的时间复杂度、空间复杂度分别是多少？
* 你的算法是否“稳定”（相等元素原相对顺序是否保留）？稳定与否对本题是否重要，为什么？

7. **与“摆动排序 II”的区别**

* 你能用一句话说清楚 LeetCode 280（本题）和 324（Wiggle Sort II）在难点与约束上的本质区别吗？
* 为什么 324 里常见“找中位数 + 三向切分 + 虚拟索引”，而 280 不需要？

你先回答第 1～2 题即可；我会根据你的回答继续追问到你薄弱的点。



