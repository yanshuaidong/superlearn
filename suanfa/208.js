/*
280. 摆动排序
给你一个的整数数组 nums, 将该数组重新排序后使 nums[0] <= nums[1] >= nums[2] <= nums[3]... 
输入数组总是有一个有效的答案。
示例 1:
输入：nums = [3,5,2,1,6,4]
输出：[3,5,1,6,2,4]
解释：[1,6,2,5,3,4]也是有效的答案
示例 2:
输入：nums = [6,6,5,6,3,8]
输出：[6,6,5,6,3,8]

下面我直接用“面试式追问”来测你的掌握程度。你按顺序回答即可（不用写很长，但要讲清楚理由/不变量/边界）。

1）这题到底在干什么（目标是什么）
要把数组变成类似锯齿一样，上下上下的结构。


4、为什么交换相邻的两个不会破坏前面的关系。
关键点是：当我在处理i的时候，只会改，numsi-1和numsi，不会更改更左边的元素。
那会不会破坏i-2和i-1的关系呢？看起来会，因为i-1有可能会比换掉。
但事实是：我们换的方向刚好保证不被破坏，直觉解释如下：
1、我们在i位置做交换，只有一个目的，让i的前一个元素和当前元素满足奇偶要求。
2、在这个i位置交换，会让i的前一个元素变大或变小。相对于原来i的位置来说。
3、而i-2和i-1的关系在上一轮已经被修好了。


0,1,2,3,4,5,6,7,8,9，

如 0, 1, 6, 8, 9 旋转 180° 以后，得到了新的数字 0, 1, 9, 8, 6 。
2, 3, 4, 5, 7 旋转 180° 后，得到的不是数字。

1是是否有效。
很简单:组合1的都有效。但凡有组合2的都无效。但凡里面有数组2里面的数字的都无效。
2是是否和原来相等。
在再组合1里面精细。
本身和非本身：
0, 1,  8,
如果是 88 ，11，
还有6特殊情况，69会变96。
通过特殊枚举或通过计算得出来。










*/ 

// 低-高-低-高
// 偶低-奇高-偶低-奇高


function wigglesort(nums){
  for(let i = 1; i < nums.length; i++){
    const shouldBeup = (i % 2 === 1); // 奇数位置
    // 如果是奇数
    if(shouldBeup){
      if(nums[i-1] >nums[i]){
        // 交换
        let temp = nums[i-1];
        nums[i-1] = nums[i];
        nums[i] = temp;
      }
    }else{
      // 是偶数
      if(nums[i-1] <nums[i]){
        // 交换
        let temp = nums[i-1];
        nums[i-1] = nums[i];
        nums[i] = temp;
      }
    }
  }
  return nums;
}

let nums = [6,6,5,6,3,8]


let res = wigglesort(nums)

console.log(res);
