/*

我在做下面的算法题目，请你不要给我答案代码。将做题思路告诉我。
我在做下面的算法题目，请你不要给我答案代码。将做题思路告诉我。
我在做下面的算法题目，请你不要给我答案代码。将做题思路告诉我。
772. 基本计算器 III

相关标签
栈
递归
数学
字符串
实现一个基本的计算器来计算简单的表达式字符串。

表达式字符串只包含非负整数，算符 +、-、*、/ ，左括号 ( 和右括号 ) 。整数除法需要 向下截断 。

你可以假定给定的表达式总是有效的。所有的中间结果的范围均满足 [-231, 231 - 1] 。

注意：你不能使用任何将字符串作为表达式求值的内置函数，比如 eval() 。

 

示例 1：

输入：s = "1+1"
输出：2
示例 2：

输入：s = "6-4/2"
输出：4
示例 3：

输入：s = "2*(5+5*2)/3+(6/2+8)"
输出：21

提示：

1 <= s <= 104
s 由整数、'+'、'-'、'*'、'/'、'(' 和 ')' 组成
s 是一个 有效的 表达式

*/ 

/**
 * @param {string} s
 * @return {number}
 * 思路：递归解析括号，+栈实现乘除优先（加减转成正负数，最后求和）
 * 
 * 关键点：
 * num 当前正在解析的数字（多位数）
 * op：num前面的运算符（决定如何把num作用到栈）
 * 栈stk 保存已确定只需要做加法求和的项
 * 遇到左括号，递归出括号内的值，当做一个num
 * 遇到右括号，当前递归结束，先把最后的num结算进栈，再返回sum（stk）
 * 除法 用Math.trunc做朝0截断。
 */
var calculate = function(s) {
  // 核心思路是栈+递归+共享索引i
  // 例子：2*(5+5*2)/3+(6/2+8)
  

  let i = 0; // 共享游标：递归层之间共享的扫描位置

  // 核心操作
  function applyOp(stk,op,num){
    // 把 num 按照 op 作用到栈
    // + push（num）
    if(op === '+') stk.push(num);
    else if (op === '-') stk.push(-num);
    // 栈顶 * 当前元素 放到栈顶
    else if (op === '*') stk.push(stk.pop() * num);
    else if (op === '/') stk.push(Math.trunc(stk.pop() / num));
  }


  function parse(){
    let stk = [];
    let num = 0;
    let op = '+'; // 初始当作 '+'，确保第一个数字能被正确入栈

    while(i<s.length){
      // 2*(5+5*2)/3+(6/2+8)
      // ch = 2 * (
      let ch = s[i];

      // 说明是个数字字符 12 形成连续的数字
      if(ch >= '0' && ch <= '9'){
        // ch = 2
        // num = 1
        num = num * 10 + (ch.charCodeAt(0) - 48);
        i++;
        continue;
      }

      // 遇到左括号，递归出括号内的表达式，返回值当num
      if(ch === '('){
        i++;  // 跳过 左括号
        num = parse();
        // 递归算法会一直匹配到右括号
        // 此时i指向右括号，在parse内遇到右括号的时候停止并返回
        // 外层会继续处理统计，
        continue;
      }

      // ch 是运算符或 右边的括号
      // 在处理当前符号之前先把刚刚跌到的num 按旧的op结算进入栈
      // 除法结算的原因：数字或表达式已经结束，或遇到运算符或右边的括号。
      if(ch === '+' || ch === '-' || ch === '*' || ch === '/' || ch === ')'){
        // 运算之前的；
        applyOp(stk, op, num);
        // 把数字重置为0；
        num = 0;

        if(ch === ')'){
          i++;
          let sum = 0;
          for(let i= 0;i<stk.length;i++){
            sum+= stk[i];
          }
          return sum;
        }
        op = ch;
        i++;
        continue;
      }
    }

    // 字符串结束：把最后积累的栈求和
    // 注意最后一个num 会在遇到结束值结算不到，因此需要额外计算一次
    // 不需要，因为我们在遇到运算符或右边的括号的时候才结算，而结尾没有符号，所以while结束后需要补充计算一次
    applyOp(stk,op,num);

    let sum = 0;
    for (let i = 0; i < stk.length; i++) {
      sum += stk[i];
    }
    return sum;
  }

  // 从头开始解析
  return parse();
};

calculate("2*(5+5*2)/3+(6/2+8)")